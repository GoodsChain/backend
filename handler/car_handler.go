package handler

import (
	"net/http"
	// "errors" // For checking specific error types from usecase if needed

	"github.com/GoodsChain/backend/model"
	"github.com/GoodsChain/backend/usecase"
	"github.com/GoodsChain/backend/repository" // For repository.ErrNotFound if bubbled up
	"github.com/gin-gonic/gin"
	// "github.com/google/uuid" // UUID generation is in usecase now
)

// CarHandler handles HTTP requests for cars
type CarHandler struct {
	carUsecase usecase.CarUsecase
}

// NewCarHandler creates a new CarHandler
func NewCarHandler(uc usecase.CarUsecase) *CarHandler {
	return &CarHandler{carUsecase: uc}
}

// CreateCar godoc
// @Summary Create a new car
// @Description Adds a new car to the system. ID is auto-generated by the backend.
// @Tags Cars
// @Accept json
// @Produce json
// @Param car body model.Car true "Car object to be created. ID, CreatedAt, CreatedBy, UpdatedAt, UpdatedBy are ignored."
// @Success 201 {object} model.Car "Successfully created car"
// @Failure 400 {object} model.ErrorResponse "Invalid request payload"
// @Failure 500 {object} model.ErrorResponse "Internal server error"
// @Router /cars [post]
func (h *CarHandler) CreateCar(c *gin.Context) {
	var car model.Car
	if err := c.ShouldBindJSON(&car); err != nil {
		c.JSON(http.StatusBadRequest, model.ErrorResponse{Code: "invalid_request", Message: err.Error()})
		return
	}

	// ID, CreatedAt, CreatedBy, UpdatedAt, UpdatedBy are handled by usecase/repository
	// Potentially set CreatedBy/UpdatedBy from authenticated user context here
	// car.CreatedBy = "user_from_context" 
	// car.UpdatedBy = "user_from_context"

	if err := h.carUsecase.CreateCar(&car); err != nil {
		// TODO: Differentiate between error types from usecase if necessary
		// e.g., if err == usecase.ErrSupplierNotFound (if validating supplier ID)
		c.JSON(http.StatusInternalServerError, model.ErrorResponse{Code: "internal_error", Message: err.Error()})
		return
	}
	c.JSON(http.StatusCreated, car)
}

// GetCar godoc
// @Summary Get a car by ID
// @Description Retrieves a car's details based on its unique ID.
// @Tags Cars
// @Produce json
// @Param id path string true "Car ID" example:"car_01H8ZJ5XQ8X5X8X5X8X5X8X5X8"
// @Success 200 {object} model.Car "Successfully retrieved car"
// @Failure 404 {object} model.ErrorResponse "Car not found"
// @Failure 500 {object} model.ErrorResponse "Internal server error"
// @Router /cars/{id} [get]
func (h *CarHandler) GetCar(c *gin.Context) {
	id := c.Param("id")
	car, err := h.carUsecase.GetCar(id)
	if err != nil {
		if err == repository.ErrNotFound { // Assuming usecase bubbles up repository.ErrNotFound
			c.JSON(http.StatusNotFound, model.ErrorResponse{Code: "not_found", Message: "Car not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, model.ErrorResponse{Code: "internal_error", Message: err.Error()})
		return
	}
	c.JSON(http.StatusOK, car)
}

// GetAllCars godoc
// @Summary Get all cars
// @Description Retrieves a list of all cars in the system.
// @Tags Cars
// @Produce json
// @Success 200 {array} model.Car "Successfully retrieved list of cars"
// @Failure 500 {object} model.ErrorResponse "Failed to retrieve cars"
// @Router /cars [get]
func (h *CarHandler) GetAllCars(c *gin.Context) {
	cars, err := h.carUsecase.GetAllCars()
	if err != nil {
		c.JSON(http.StatusInternalServerError, model.ErrorResponse{Code: "internal_error", Message: "Failed to retrieve cars"})
		return
	}
	c.JSON(http.StatusOK, cars)
}

// UpdateCar godoc
// @Summary Update an existing car
// @Description Updates the details of an existing car identified by its ID.
// @Tags Cars
// @Accept json
// @Produce json
// @Param id path string true "Car ID" example:"car_01H8ZJ5XQ8X5X8X5X8X5X8X5X8"
// @Param car body model.Car true "Car object with updated details. ID, CreatedAt, CreatedBy, UpdatedAt are ignored."
// @Success 200 {object} model.SuccessResponse "Car updated successfully"
// @Failure 400 {object} model.ErrorResponse "Invalid request payload"
// @Failure 404 {object} model.ErrorResponse "Car not found"
// @Failure 500 {object} model.ErrorResponse "Internal server error"
// @Router /cars/{id} [put]
func (h *CarHandler) UpdateCar(c *gin.Context) {
	id := c.Param("id")
	var car model.Car
	if err := c.ShouldBindJSON(&car); err != nil {
		c.JSON(http.StatusBadRequest, model.ErrorResponse{Code: "invalid_request", Message: err.Error()})
		return
	}

	// Potentially set UpdatedBy from authenticated user context here
	// car.UpdatedBy = "user_from_context"

	if err := h.carUsecase.UpdateCar(id, &car); err != nil {
		if err == repository.ErrNotFound { // Assuming usecase bubbles up repository.ErrNotFound
			c.JSON(http.StatusNotFound, model.ErrorResponse{Code: "not_found", Message: "Car not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, model.ErrorResponse{Code: "internal_error", Message: err.Error()})
		return
	}
	c.JSON(http.StatusOK, model.SuccessResponse{Message: "Car updated successfully"})
}

// DeleteCar godoc
// @Summary Delete a car
// @Description Deletes a car from the system based on its unique ID.
// @Tags Cars
// @Produce json
// @Param id path string true "Car ID" example:"car_01H8ZJ5XQ8X5X8X5X8X5X8X5X8"
// @Success 200 {object} model.SuccessResponse "Car deleted successfully"
// @Failure 404 {object} model.ErrorResponse "Car not found"
// @Failure 500 {object} model.ErrorResponse "Internal server error"
// @Router /cars/{id} [delete]
func (h *CarHandler) DeleteCar(c *gin.Context) {
	id := c.Param("id")
	if err := h.carUsecase.DeleteCar(id); err != nil {
		if err == repository.ErrNotFound { // Assuming usecase bubbles up repository.ErrNotFound
			c.JSON(http.StatusNotFound, model.ErrorResponse{Code: "not_found", Message: "Car not found"})
			return
		}
		c.JSON(http.StatusInternalServerError, model.ErrorResponse{Code: "internal_error", Message: err.Error()})
		return
	}
	c.JSON(http.StatusOK, model.SuccessResponse{Message: "Car deleted successfully"})
}
