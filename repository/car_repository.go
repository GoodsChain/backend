package repository

import (
	"database/sql"
	"errors"
	"time"

	"github.com/GoodsChain/backend/model"
	"github.com/jmoiron/sqlx"
)

// CarRepository defines the interface for car data operations
type CarRepository interface {
	CreateCar(car *model.Car) error
	GetCarByID(id string) (*model.Car, error)
	GetAllCars() ([]model.Car, error)
	UpdateCar(id string, car *model.Car) error
	DeleteCar(id string) error
}

type carRepository struct {
	db *sqlx.DB
}

// NewCarRepository creates a new instance of CarRepository
func NewCarRepository(db *sqlx.DB) CarRepository {
	return &carRepository{db: db}
}

// CreateCar adds a new car to the database
func (r *carRepository) CreateCar(car *model.Car) error {
	// Assuming ID is generated by the database or application layer before this call
	// For consistency with other models, ID, CreatedAt, UpdatedAt are set here or by DB
	car.CreatedAt = time.Now()
	car.UpdatedAt = time.Now()
	// CreatedBy and UpdatedBy should be set by the application/usecase layer

	query := `INSERT INTO car (id, name, supp_id, price, created_at, created_by, updated_at, updated_by)
              VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`
	_, err := r.db.Exec(query, car.ID, car.Name, car.SupplierID, car.Price, car.CreatedAt, car.CreatedBy, car.UpdatedAt, car.UpdatedBy)
	return err
}

// GetCarByID retrieves a car by its ID
func (r *carRepository) GetCarByID(id string) (*model.Car, error) {
	var car model.Car
	query := `SELECT id, name, supp_id, price, created_at, created_by, updated_at, updated_by FROM car WHERE id = $1`
	err := r.db.Get(&car, query, id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound // Consider a shared ErrNotFound
		}
		return nil, err
	}
	return &car, nil
}

// GetAllCars retrieves all cars from the database
func (r *carRepository) GetAllCars() ([]model.Car, error) {
	var cars []model.Car
	query := `SELECT id, name, supp_id, price, created_at, created_by, updated_at, updated_by FROM car ORDER BY created_at DESC`
	err := r.db.Select(&cars, query)
	if err != nil {
		return nil, err
	}
	return cars, nil
}

// UpdateCar updates an existing car's information
func (r *carRepository) UpdateCar(id string, car *model.Car) error {
	car.UpdatedAt = time.Now()
	// UpdatedBy should be set by the application/usecase layer

	query := `UPDATE car SET name = $1, supp_id = $2, price = $3, updated_at = $4, updated_by = $5 WHERE id = $6`
	result, err := r.db.Exec(query, car.Name, car.SupplierID, car.Price, car.UpdatedAt, car.UpdatedBy, id)
	if err != nil {
		return err
	}
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rowsAffected == 0 {
		return ErrNotFound // Or a more specific error like ErrCarNotFound
	}
	return nil
}

// DeleteCar removes a car from the database by its ID
func (r *carRepository) DeleteCar(id string) error {
	query := `DELETE FROM car WHERE id = $1`
	result, err := r.db.Exec(query, id)
	if err != nil {
		return err
	}
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rowsAffected == 0 {
		return ErrNotFound // Or a more specific error like ErrCarNotFound
	}
	return nil
}

// ErrNotFound is a common error for "record not found"
// This should ideally be in a shared package or defined per repository if specific errors are needed.
var ErrNotFound = errors.New("requested record not found")
